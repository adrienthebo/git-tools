#!/usr/bin/env ruby
#
# Given a number of branches, checks if they've been merged into a set of branches

require 'optparse'

begin
  require 'rubygems'
  require 'colorize'
  require 'terminal-table'
rescue LoadError => e
  $stderr.puts "#{File.basename $0} needs the colorize and terminal-table gems, #{e}"
  exit 126
end


# Given a symbolic reference and a branch, returns whether the symbolic
# reference has been merged into that branch
def merged?(symbolic, branch)
  sha1 = %x{git log -1 --pretty="format:%h" #{symbolic}}
  contains = %x{git branch --contains #{sha1} | grep #{branch}}
  not contains.empty?
end

def remote_branches
  output = %x{git branch -r}
  branches = output.split(/\n/)
  branches.map! {|line| line.scan(/\S+/).first}
  branches.delete_if {|branch| branch.match %r[/HEAD$]}

  branches
end

def local_branches
  output = %x{git branch}
  branches = output.split(/\n/)
  branches.map! {|line| line.sub(/\*/, '').strip}

  branches
end

def current_branch
  output = %x{git branch}
  branches = output.split(/\n/)
  branch = branches.select {|br| br.match /\*/ }.first
  branch.sub!(/\*/, '')
  branch.strip!

  branch
end

check_branches = []
integration_branch = nil
options = {}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} [options]"

  opts.on("--branch=val", 'The branch to check for merges') do |param|
    raise ArgumentError, 'Option "--branch" can only be specified once!' if integration_branch
    integration_branch = param
  end

  opts.on('-r', '--remote', 'Check all remote branches') do
    options[:remote] = true
  end

  opts.on('-l', '--local', 'Check all local branches') do
    options[:local] = true
  end

  opts.on('-a', '--all', 'Check every branch ever') do
    options[:remote] = true
    options[:local] = true
  end

  opts.on_tail("-h", "--help", "Display this help") do
    puts opts
    exit 0
  end
end

begin
  parser.parse!
rescue => e
  $stderr.puts e
  $stderr.puts parser
  exit 1
end

if integration_branch.nil? or integration_branch.empty?
  integration_branch = 'master'
end

check_branches += remote_branches if options[:remote]
check_branches += local_branches if options[:local]

if check_branches.empty?
  if ARGV.empty?
    check_branches << current_branch
  else
    check_branches += ARGV
  end
end

rows = check_branches.map do |branch|

  msg   = nil
  color = nil
  if merged? branch, integration_branch
    msg = "merged"
    color = :green
  else
    msg = "NOT merged"
    color = :red
  end

  # We have to dup this variable because we can't directly modify a variable
  # that may have been in ARGV
  colorized_branch = branch.dup.colorize(color)
  colorized_msg    = msg.colorize(color)
  [colorized_branch, colorized_msg]
end

puts Terminal::Table.new :headings => %w{Branch Status}, :rows => rows
